/** @page tutorial_simple A simple client/server

Let's take a look at a really simple Atlas-C++ client and server. All that the
server was is wait for a connection, receive something from the client and
wait for the connection to close. The client connects to the server, sends a
message and then closes the connection.

Both client and server use libsocket++ (see @ref tutorial_preamble) for socket
communications.

@section server The Server

See under the code for more documentation.

@verbinclude simple_server.cc

As mentioned before, the server does the following:

<ol>
  <li>Wait for a connection</li>
  <li>Accept a client connection</li>
  <li>Negotiate with the connecting client</li>
  <li>Receive messages from the client and wait for it to disconnect</li>
</ol>

Only steps 3 and 4 really involve Atlas-C++, the rest is handled by the socket
library I'm using (libsocket++, see @ref tutorial_preamble).



@section client The Client

@verbinclude simple_client.cc

@section debug_bridge DebugBridge

In the above client + server a class called DebugBridge is used. This class is
not part of Atlas-C++, but rather one that we made ourselves. It is passed to
the negotiation classes (StreamConnect and StreamAccept) which then pass it on
to the codec returned by GetCodec().

DebugBridge simply prints out everything it receives onto cout. The source
code should be quite easily understandable.

@verbinclude DebugBridge.h

@ref tutorial_preamble "Previous"
@ref tutorial_index "Index"
@ref tutorial_message "Next"

@author Stefanus Du Toit <sdt@gmx.net>
*/
